// Generated by CoffeeScript 1.12.6
(function() {
  var chalk, config, dataStoreDir, fetchQuestions, fetchSection, fetchSectionList, fs, getProcessedQuestions, getProcessedSections, loadRawQuestions, loadRawSections, localImgQuestionFilePath, logActionEnd, logActionStart, path, remoteImgQuestionFilePath, saveFile, sectionFilePath, throwErr;

  config = require('../config');

  path = require('path');

  fs = require('fs');

  chalk = require('chalk');

  fetchSectionList = require('./fetch/fetchSectionList');

  fetchSection = require('./fetch/fetchSection');

  fetchQuestions = require('./fetch/fetchQuestions');

  dataStoreDir = config.dataStoreDirPath;

  sectionFilePath = path.resolve(dataStoreDir, 'sections.test.json');

  remoteImgQuestionFilePath = path.resolve(dataStoreDir, 'remoteImgQuestions.test.json');

  localImgQuestionFilePath = path.resolve(dataStoreDir, 'localImgQuestions.test.json');

  logActionStart = function(description) {
    return console.info(chalk.green('\n' + description.toUpperCase()));
  };

  logActionEnd = function(description) {
    return console.info(chalk.green('FINISHED ' + description.toUpperCase()));
  };

  throwErr = function(err, descriptionOfAction) {
    console.error('\n');
    console.error(chalk.red.bold('ERROR OCCURRED WHILE ' + descriptionOfAction.toUpperCase()));
    console.error(chalk.red.bold(err.stack));
    return process.exit(1);
  };

  loadRawSections = function() {
    var actionName, actionName2;
    actionName = 'loading section list';
    actionName2 = 'loading sections';
    logActionStart(actionName);
    return fetchSectionList()["catch"](function(err) {
      return throwErr(err, actionName);
    }).then(function(sectionList) {
      logActionEnd(actionName);
      return sectionList;
    }).then(function(sectionList) {
      var section, sectionPromises;
      logActionStart(actionName2);
      sectionPromises = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = sectionList.length; i < len; i++) {
          section = sectionList[i];
          results.push(fetchSection(section).then(function(section) {
            if (section != null) {
              console.info('loaded section: ' + section.id + ' (' + section.name + ')');
            }
            return section;
          }));
        }
        return results;
      })();
      return Promise.all(sectionPromises);
    }).then(function(sections) {
      sections = sections.filter(function(section) {
        return section != null;
      });
      logActionEnd(actionName2);
      return sections;
    })["catch"](function(err) {
      return throwErr(err, actionName2);
    });
  };

  loadRawQuestions = function() {
    var actionName;
    actionName = 'loading questions';
    logActionStart(actionName);
    return fetchQuestions()["catch"](function(err) {
      return throwErr(err, actionName);
    }).then(function(questions) {
      logActionEnd(actionName);
      return questions;
    });
  };

  getProcessedSections = function(rawSections) {
    var actionName, section, sections;
    actionName = 'processing sections';
    logActionStart(actionName);
    sections = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = rawSections.length; i < len; i++) {
        section = rawSections[i];
        results.push(Object.assign({}, section, {
          questions: section.questions.map(function(question) {
            return question.id;
          })
        }));
      }
      return results;
    })();
    logActionEnd(actionName);
    return sections;
  };

  getProcessedQuestions = function(rawQuestions, rawSections) {
    var actionName, code, i, id, j, k, len, len1, len2, q, question, questionMap, questions, ref, ref1, section;
    actionName = 'processing questions';
    logActionStart(actionName);
    questionMap = {};
    for (i = 0, len = rawQuestions.length; i < len; i++) {
      q = rawQuestions[i];
      questionMap[q.code] = q;
    }
    questions = [];
    for (j = 0, len1 = rawSections.length; j < len1; j++) {
      section = rawSections[j];
      ref = section.questions;
      for (k = 0, len2 = ref.length; k < len2; k++) {
        ref1 = ref[k], id = ref1.id, code = ref1.code;
        question = questionMap[code];
        if (question == null) {
          console.warn(chalk.cyan.bold('missing question: ' + id + ' (' + code + ')'));
          continue;
        }
        questions.push(Object.assign({}, question, {
          id: id,
          value: section.value
        }));
      }
    }
    logActionEnd(actionName);
    return questions;
  };

  saveFile = function(path, data, dataType) {
    var actionName, changed, err, newJson, originalJson;
    actionName = 'saving ' + dataType;
    logActionStart(actionName);
    newJson = JSON.stringify(data);
    try {
      originalJson = fs.readFileSync(path, {
        encoding: 'utf8'
      });
    } catch (error) {
      err = error;
      originalJson = null;
    }
    if (newJson === originalJson) {
      console.info('no changes in ' + dataType);
      changed = false;
    } else {
      fs.writeFileSync(path, newJson);
      fs.writeFileSync(path + '.lastChange', Date.now().toString());
      if (originalJson != null) {
        fs.writeFileSync(path + '.old', originalJson);
      }
      console.info('updated ' + dataType);
      changed = true;
    }
    logActionEnd(actionName);
    return changed;
  };

  loadRawSections().then(function(rawSections) {
    return Promise.all([rawSections, loadRawQuestions()]);
  }).then(function(arg) {
    var questions, questionsChanged, rawQuestions, rawSections, sections, sectionsChanged;
    rawSections = arg[0], rawQuestions = arg[1];
    sections = getProcessedSections(rawSections);
    questions = getProcessedQuestions(rawQuestions, rawSections);
    sectionsChanged = saveFile(sectionFilePath, sections, 'sections');
    questionsChanged = saveFile(remoteImgQuestionFilePath, questions, 'questions');
    console.log('');
    console.log(chalk.magenta('UPDATE FINISHED:'));
    console.log(chalk.magenta('	sections were updated: ' + sectionsChanged.toString().toUpperCase()));
    return console.log(chalk.magenta('	questions were updated: ' + questionsChanged.toString().toUpperCase()));
  });

}).call(this);

//# sourceMappingURL=index.js.map
