separateItemWithMeta = require('./separateItemWithMeta')
rewriteMetaToSymbol = require('./rewriteMetaToSymbol')

getDb = require('./store/getDb')
getMemoryStore = require('./store/getMemoryStore')

itemOperations = require('./operations/index')

generateStructure = require('./structure/generateStructure')
updateStructure = require('./structure/updateStructure')
getClearStructure = require('./structure/getClearStructure')

validateItemWithMeta = (item) ->
	if item == null
		throw new Error('item must be object, not null')
	if typeof item != 'object'
		throw new Error('item must be object, not ' + typeof item)
	if !item[metaSymbol]?
		throw new Error('item has missing metadata - you must only pass object generated by eveStore')


ALREADY_LOADED_NAMESPACES = []
metaSymbol = Symbol('eveStore metadata')

module.exports = (storeNamespace) ->
	if ALREADY_LOADED_NAMESPACES.indexOf(storeNamespace) > -1
		throw new Error('eveStore instance already loaded for this namespace - only one instance for each namespace is allowed')
	ALREADY_LOADED_NAMESPACES.push(storeNamespace)

	store =
		db: getDb(storeNamespace)
		memory: getMemoryStore()

	structure = generateStructure(store)

	listeners = {}
	emit = (opType, message, data) ->
		if listeners[opType]?
			for cb in listeners[opType]
				cb(message, data, opType)
		if listeners['*']?
			for cb in listeners['*']
				cb(message, data, opType)
		return

	return {
		add: (tag, persist, item) ->
			if arguments.length == 1
				item = tag
				persist = null
				tag = null

			if arguments.length == 2
				item = persist
				if typeof tag == 'boolean'
					persist = tag
					tag = null
				else
					persist = null

			if typeof item != 'object'
				throw new Error('item must be object, not ' + typeof item)

			returnedItem = itemOperations.add({
				item: item
				meta: {tag: tag, persistent: persist}
			}, store, structure)

			structure = updateStructure.add(structure, returnedItem, store)
			rewrittenItem = rewriteMetaToSymbol(returnedItem, metaSymbol)
			emit('add', "Added new item to `#{storeNamespace}` (id: #{returnedItem.meta.id})", rewrittenItem)
			return rewrittenItem


		remove: (itemWithMeta, __suppressMessages = false) ->
			if typeof itemWithMeta == 'number'
				itemOrId = itemWithMeta
			else
				validateItemWithMeta(itemWithMeta)
				itemOrId = separateItemWithMeta(itemWithMeta, metaSymbol)

			removedItem = itemOperations.remove(itemOrId, store, structure)
			if removedItem?
				structure = updateStructure.remove(structure, removedItem, store)
			rewrittenItem = rewriteMetaToSymbol(removedItem, metaSymbol)

			if !__suppressMessages
				if removedItem?
					emit('remove',
						"Removed item from `#{storeNamespace}` (id: #{removedItem.meta.id},
							added #{Math.floor((Date.now() - removedItem.meta.writeTime) / 1000)} seconds ago)",
						rewrittenItem)
				else
					emit('remove', "Attempted to remove missing item
							(id: #{if typeof itemOrId == 'number' then itemOrId else itemOrId.meta.id})",
						null)

			return rewrittenItem


		removeByQuery: (query) ->
			unfilteredResult = @find(query, true)
				.map((item) => @remove(item, true))
			result = unfilteredResult.filter((item) -> item?)

			emit('removeByQuery', "Removed items by query
					(removedItemCount: #{result.length}, foundItemCount: #{unfilteredResult.length})",
				{query: query, foundItemCount: unfilteredResult.length, removedItemCount: result.length})

			return result


		get: (id) ->
			item = rewriteMetaToSymbol(itemOperations.get(id, store, structure), metaSymbol)
			emit('get', "Looking up item by ID (id: #{id})", item)
			return item


		find: (query, __suppressMessages = false) ->
			items = itemOperations.find(query, store, structure)
				.filter((i) -> i?)
				.map((i) -> rewriteMetaToSymbol(i, metaSymbol))
			if !__suppressMessages
				emit('find', "Querying store to find items (itemCount: #{items.length})", {query: query, itemCount: items.length})
			return items


		findOne: (query) ->
			# TODO: possibly optimize to its own method
			result = @find(query)[0]
			if !result?
				result = null
			return result


		clear: ->
			store.db.clear()
			store.memory.clear()
			structure = getClearStructure()
			emit('clear', 'Store cleared')
			return



		persistentStorageAvailable: ->
			return store.db.isAvailable()

		getMetadata: (itemWithMeta) ->
			validateItemWithMeta(itemWithMeta)
			return Object.assign({}, itemWithMeta[metaSymbol])


		__on: (operationType, cb) ->
			if !listeners[operationType]?
				listeners[operationType] = []
			listeners[operationType].push(cb)
			return

		__getStructure: ->
			return structure
	}