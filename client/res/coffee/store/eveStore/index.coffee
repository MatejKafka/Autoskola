separateItemWithMeta = require('./separateItemWithMeta')
rewriteMetaToSymbol = require('./rewriteMetaToSymbol')
StorageFullError = require('./store/StorageFullError')

getDb = require('./store/getDb')
getMemoryStore = require('./store/getMemoryStore')

itemOperations = require('./operations/index')

generateStructure = require('./structure/generateStructure')
updateStructure = require('./structure/updateStructure')
getClearStructure = require('./structure/getClearStructure')

isItemWithMeta = (item) ->
	return item? && typeof item == 'object' && item[metaSymbol]?

validateItemWithMeta = (item) ->
	if item == null
		throw new Error('item must be object, not null')
	if typeof item != 'object'
		throw new Error('item must be object, not ' + typeof item)
	if !item[metaSymbol]?
		throw new Error('item is not eveStore item - you must only pass item object generated by eveStore')


ALREADY_LOADED_NAMESPACES = []
metaSymbol = Symbol('eveStore metadata')

# TODO: add customizable caching - method that accepts query without values and creates cache for it
module.exports = (storeNamespace) ->
	if ALREADY_LOADED_NAMESPACES.indexOf(storeNamespace) > -1
		throw new Error('eveStore instance already loaded for this namespace - only one instance for each namespace is allowed')
	ALREADY_LOADED_NAMESPACES.push(storeNamespace)

	store =
		db: getDb(storeNamespace)
		memory: getMemoryStore()

	structure = generateStructure(store)

	listeners = {}
	emit = (opType, message, data) ->
		if listeners[opType]?
			for cb in listeners[opType]
				cb(message, data, opType)
		if listeners['*']?
			for cb in listeners['*']
				cb(message, data, opType)
		return

	return eve = {
		add: (tag, persist, item) ->
			if arguments.length == 1
				item = tag
				persist = null
				tag = null

			else if arguments.length == 2
				item = persist
				if typeof tag == 'boolean'
					persist = tag
					tag = null
				else
					persist = null

			if typeof item != 'object'
				throw new Error('item must be object, not ' + typeof item)

			if isItemWithMeta(item)
				console.warn('to update item, use store.update, not store.add')

			returnedItem = itemOperations.add({
				item: item
				meta: {tag: tag, persistent: persist}
				isExisting: false
			}, store, structure)

			structure = updateStructure.add(structure, returnedItem, store)
			rewrittenItem = rewriteMetaToSymbol(returnedItem, metaSymbol)
			emit('add', "Added new item to `#{storeNamespace}` (id: #{returnedItem.meta.id})", rewrittenItem)
			return rewrittenItem


		update: (item) ->
			validateItemWithMeta(item)

			separatedItem = separateItemWithMeta(item, metaSymbol)
			separatedItem.isExisting = true

			returnedItem = itemOperations.add(separatedItem, store, structure)
			# TODO: if structure will be extended to cache other values, add updateStructure.change call here
			rewrittenItem = rewriteMetaToSymbol(returnedItem, metaSymbol)

			emit('update', "Updated item (id: #{returnedItem.meta.id})", rewrittenItem)
			return rewrittenItem


		remove: (itemOrId, __suppressMessages = false) ->
			if Array.isArray(itemOrId)
				removedItems = for item in itemOrId
					eve.remove(item, __suppressMessages)
				return removedItems

			if typeof itemOrId != 'number'
				validateItemWithMeta(itemOrId)
				itemOrId = separateItemWithMeta(itemOrId, metaSymbol)

			removedItem = itemOperations.remove(itemOrId, store, structure)
			if removedItem?
				structure = updateStructure.remove(structure, removedItem, store)
			rewrittenItem = rewriteMetaToSymbol(removedItem, metaSymbol)

			if !__suppressMessages
				if removedItem?
					emit('remove',
						"Removed item from `#{storeNamespace}` (id: #{removedItem.meta.id},
							added #{Math.floor((Date.now() - removedItem.meta.writeTime) / 1000)} seconds ago)",
						rewrittenItem)
				else
					emit('remove', "Attempted to remove missing item
							(id: #{if typeof itemOrId == 'number' then itemOrId else itemOrId.meta.id})",
						null)

			return rewrittenItem


		removeByQuery: (query) ->
			unfilteredResult = eve.find(query, true)
				.map((item) => eve.remove(item, true))
			result = unfilteredResult.filter((item) -> item?)

			emit('removeByQuery', "Removed items by query
					(removedItemCount: #{result.length}, foundItemCount: #{unfilteredResult.length})",
				{query: query, foundItemCount: unfilteredResult.length, removedItemCount: result.length})

			return result


		get: (id) ->
			item = rewriteMetaToSymbol(itemOperations.get(id, store, structure), metaSymbol)
			emit('get', "Looking up item by ID (id: #{id})", item)
			return item


		find: (query, __suppressMessages = false, __singleRecord = false) ->
			items = itemOperations.find(query, store, structure, __singleRecord)
				.filter((i) -> i?)
				.map((i) -> rewriteMetaToSymbol(i, metaSymbol))
			if !__suppressMessages
				emit('find', "Querying store to find items (itemCount: #{items.length})", {query: query, itemCount: items.length})
			return items


		findOne: (query) ->
			result = eve.find(query, null, true)[0]
			if !result?
				result = null
			return result


		forEach: (fn) ->
			cb = (item) ->
				fn(rewriteMetaToSymbol(item, metaSymbol))
			store.db.forEachItem(cb)
			store.memory.forEachItem(cb)
			return


		clear: ->
			store.db.clear()
			store.memory.clear()
			structure = getClearStructure()
			emit('clear', 'Store cleared')
			return



		StorageFullError: StorageFullError

		persistentStorageAvailable: ->
			return store.db.isAvailable()


		getMetadata: (item) ->
			validateItemWithMeta(item)
			return Object.assign({}, separateItemWithMeta(item, metaSymbol).meta)


		__on: (operationType, cb) ->
			if !listeners[operationType]?
				listeners[operationType] = []
			listeners[operationType].push(cb)
			return


		__dumpItem: (item) ->
			validateItemWithMeta(item)
			item = separateItemWithMeta(item, metaSymbol)

			str = ''
			if item.meta.tag?
				str += "##{item.meta.tag}\n"
			else
				str += 'NO_TAG'

			str += "\tstore:#{if item.meta.persistent then 'persistent' else 'memory'}\n
					\twriteTime: #{Date(item.meta.writeTime)} \n\t"

			console.log(str, item.item)
			return str
	}